#include "BookManager.h"
#include "Sorting.h"
#include "Searching.h"
#include <QFile>
#include <QJsonArray>
#include <QJsonObject>
#include <QDebug>
#include <QDateTime>
#include <set>
#include <algorithm> // Only for std::swap and std::remove_if

BookManager::BookManager()
    : m_bstRoot(nullptr), m_graph()
{
}

bool BookManager::loadFromJson(const QString& filePath)
{
    QFile file(filePath);
    if (!file.open(QIODevice::ReadOnly)) {
        qWarning() << "Failed to open file:" << filePath;
        return false;
    }

    QByteArray data = file.readAll();
    file.close();

    QJsonDocument doc = QJsonDocument::fromJson(data);
    if (doc.isNull() || !doc.isObject()) {
        qWarning() << "Invalid JSON format";
        return false;
    }

    QJsonObject root = doc.object();
    QJsonArray booksArray = root["books"].toArray();

    m_books.clear();
    for (const QJsonValue& value : booksArray) {
        if (value.isObject()) {
            Book book = Book::fromJson(value.toObject());
            m_books.push_back(book);
        }
    }

    qDebug() << "Loaded" << m_books.size() << "books from" << filePath;
    return true;
}

bool BookManager::saveToJson(const QString& filePath)
{
    QJsonArray booksArray;
    for (const Book& book : m_books) {
        booksArray.append(book.toJson());
    }

    QJsonObject root;
    root["books"] = booksArray;

    QJsonDocument doc(root);
    
    QFile file(filePath);
    if (!file.open(QIODevice::WriteOnly)) {
        qWarning() << "Failed to open file for writing:" << filePath;
        return false;
    }

    file.write(doc.toJson(QJsonDocument::Indented));
    file.close();

    qDebug() << "Saved" << m_books.size() << "books to" << filePath;
    return true;
}

Book* BookManager::getBookById(int id)
{
    for (Book& book : m_books) {
        if (book.getId() == id) {
            return &book;
        }
    }
    return nullptr;
}

void BookManager::addBook(const Book& book)
{
    m_books.push_back(book);
    
    // Auto-update graph when book is added
    // This ensures graph is always in sync with book collection
    if (!m_books.empty()) {
        buildGraph();
    }
}

bool BookManager::removeBook(int id)
{
    // Find the book to save it to undo stack before removing
    Book* bookToDelete = getBookById(id);
    if (bookToDelete) {
        // Push to undo stack (LIFO - Last In First Out)
        m_deletedBooks.push(*bookToDelete);
        qDebug() << "Added to undo stack:" << bookToDelete->getJudul();
    }
    
    auto it = std::remove_if(m_books.begin(), m_books.end(),
                             [id](const Book& book) { return book.getId() == id; });
    
    if (it != m_books.end()) {
        m_books.erase(it, m_books.end());
        return true;
    }
    return false;
}

bool BookManager::updateBook(const Book& book)
{
    Book* existingBook = getBookById(book.getId());
    if (existingBook) {
        *existingBook = book;
        return true;
    }
    return false;
}

// ============================================================================
// SORTING ALGORITHMS - Using Sorting.h Library (QuickSort ONLY)
// ============================================================================

void BookManager::quickSortByTitle(bool ascending)
{
    if (m_books.empty()) return;

    // Use Sorting::quickSort from Sorting.h library
    auto compare = ascending
        ? [](const Book& a, const Book& b) { 
            return a.getJudul().toLower() < b.getJudul().toLower(); 
          }
        : [](const Book& a, const Book& b) { 
            return a.getJudul().toLower() > b.getJudul().toLower(); 
          };

    Sorting::quickSort(m_books, compare);
}

void BookManager::quickSortByYear(bool ascending)
{
    if (m_books.empty()) return;

    // Use Sorting::quickSort from Sorting.h library
    auto compare = ascending
        ? [](const Book& a, const Book& b) { return a.getTahun() < b.getTahun(); }
        : [](const Book& a, const Book& b) { return a.getTahun() > b.getTahun(); };

    Sorting::quickSort(m_books, compare);
}

void BookManager::quickSortByRating(bool ascending)
{
    if (m_books.empty()) return;

    // Use Sorting::quickSort from Sorting.h library
    auto compare = ascending
        ? [](const Book& a, const Book& b) { return a.getRating() < b.getRating(); }
        : [](const Book& a, const Book& b) { return a.getRating() > b.getRating(); };

    Sorting::quickSort(m_books, compare);
}

void BookManager::quickSortByAuthor(bool ascending)
{
    if (m_books.empty()) return;

    // Use Sorting::quickSort from Sorting.h library
    auto compare = ascending
        ? [](const Book& a, const Book& b) { 
            return a.getPenulis().toLower() < b.getPenulis().toLower(); 
          }
        : [](const Book& a, const Book& b) { 
            return a.getPenulis().toLower() > b.getPenulis().toLower(); 
          };

    Sorting::quickSort(m_books, compare);
}

// ============================================================================
// SEARCHING ALGORITHMS - Using Searching.h Library
// ============================================================================

Book* BookManager::binarySearchByTitle(const QString& title)
{
    if (m_books.empty()) return nullptr;

    // Use Searching::binarySearch from Searching.h library
    QString searchKey = title.toLower();
    
    int index = Searching::binarySearch(
        m_books,
        [&searchKey](const Book& book) { 
            return book.getJudul().toLower() == searchKey; 
        },
        [](const Book& a, const Book& b) {
            return a.getJudul().toLower() < b.getJudul().toLower();
        }
    );

    return (index != -1) ? &m_books[index] : nullptr;
}

std::vector<Book> BookManager::searchByGenre(const QString& genre) const
{
    // Use Searching::findAll from Searching.h library (Linear Search)
    // NO manual for loop!
    std::vector<int> indices = Searching::findAll(
        m_books,
        [&genre](const Book& book) {
            return book.hasGenre(genre);
        }
    );
    
    // Build result vector from indices
    std::vector<Book> result;
    result.reserve(indices.size());
    for (int idx : indices) {
        result.push_back(m_books[idx]);
    }
    
    return result;
}

std::vector<Book> BookManager::searchByAuthor(const QString& author) const
{
    // Use Searching::findAll from Searching.h library (Linear Search)
    // NO manual for loop!
    QString authorLower = author.toLower();
    
    std::vector<int> indices = Searching::findAll(
        m_books,
        [&authorLower](const Book& book) {
            return book.getPenulis().toLower().contains(authorLower);
        }
    );
    
    // Build result vector from indices
    std::vector<Book> result;
    result.reserve(indices.size());
    for (int idx : indices) {
        result.push_back(m_books[idx]);
    }
    
    return result;
}

std::vector<Book> BookManager::searchByYearRange(int minYear, int maxYear) const
{
    // Use Searching::findAll from Searching.h library (Linear Search)
    // NO manual for loop!
    std::vector<int> indices = Searching::findAll(
        m_books,
        [minYear, maxYear](const Book& book) {
            int year = book.getTahun();
            return year >= minYear && year <= maxYear;
        }
    );
    
    // Build result vector from indices
    std::vector<Book> result;
    result.reserve(indices.size());
    for (int idx : indices) {
        result.push_back(m_books[idx]);
    }
    
    if (m_deletedBooks.empty()) {
        qDebug() << "Undo stack is empty";
        return false;
    }
    
    // Pop from stack (LIFO - Last In First Out)
    Book restoredBook = m_deletedBooks.top();
    m_deletedBooks.pop();
    
    // Add book back to collection
    m_books.push_back(restoredBook);
    
    qDebug() << "Restored book:" << restoredBook.getJudul();
    return true;
}

// ============================================================================
// QUEUE - Book Borrowing Queue Feature Implementation
// ============================================================================

bool BookManager::addToBorrowQueue(const QString& borrowerName, int bookId)
{
    Book* book = getBookById(bookId);
    if (!book) {
        qDebug() << "Book with ID" << bookId << "not found";
        return false;
    }
    
    QString currentTime = QDateTime::currentDateTime().toString("yyyy-MM-dd HH:mm:ss");
    BorrowRequest request(borrowerName, bookId, book->getJudul(), currentTime);
    
    // Add to queue (FIFO - First In First Out)
    m_borrowQueue.push(request);
    
    qDebug() << "Added borrow request:" << borrowerName << "for" << book->getJudul();
    return true;
}

BookManager::BorrowRequest BookManager::processNextBorrow()
{
    if (m_borrowQueue.empty()) {
        qDebug() << "Borrow queue is empty";
        return BorrowRequest();
    }
    
    // Get front of queue (FIFO - First In First Out)
    BorrowRequest request = m_borrowQueue.front();
    m_borrowQueue.pop();
    
    qDebug() << "Processed borrow request:" << request.borrowerName << "for" << request.bookTitle;
    return request;
}

std::vector<BookManager::BorrowRequest> BookManager::getAllBorrowRequests() const
{
    std::vector<BorrowRequest> requests;
    std::queue<BorrowRequest> tempQueue = m_borrowQueue;
    
    while (!tempQueue.empty()) {
        requests.push_back(tempQueue.front());
        tempQueue.pop();
    }
    
    return requests;
}

// ============================================================================
// PRIORITY QUEUE - Popular Books by Rating Implementation
// ============================================================================

std::vector<Book> BookManager::getTopRatedBooks(int topN)
{
    if (m_books.empty()) {
        return std::vector<Book>();
    }
    
    // Create max heap (priority queue) based on rating
    auto compareRating = [](const Book& a, const Book& b) {
        return a.getRating() < b.getRating(); // Max heap
    };
    
    std::priority_queue<Book, std::vector<Book>, decltype(compareRating)> maxHeap(compareRating);
    // Use Searching::findAll for filtering (NO manual for loop)
    std::vector<int> indices = Searching::findAll(
        m_books,
        [minRating](const Book& book) {
            return book.getRating() >= minRating;
        }
    );
    
    // Build result vector
    std::vector<Book> popularBooks;
    popularBooks.reserve(indices.size());
    for (int idx : indices) {
        popularBooks.push_back(m_books[idx]);
    }
    
    // Sort by rating (descending) using Sorting::quickSort
    Sorting::quickSort(popularBooks, [](const Book& a, const Book& b) {
        return a.getRating() > b.getRating();

    return topBooks;
}

std::vector<Book> BookManager::getPopularBooks(double minRating)
{
    std::vector<Book> popularBooks;
    
    for (const Book& book : m_books) {
        if (book.getRating() >= minRating) {
            popularBooks.push_back(book);
        }
    }
    
    // Sort by rating (descending)
    std::sort(popularBooks.begin(), popularBooks.end(),
              [](const Book& a, const Book& b) {
                  return a.getRating() > b.getRating();
              });
    
    return popularBooks;
}

// ============================================================================
// BINARY SEARCH TREE - Catalog Structure Implementation
// ============================================================================

void BookManager::buildBST()
{
    m_bstRoot = nullptr;
    
    for (const Book& book : m_books) {
        m_bstRoot = insertBST(m_bstRoot, book);
    }
    
    qDebug() << "Built BST with" << m_books.size() << "books";
}

std::shared_ptr<BookManager::BSTNode> BookManager::insertBST(std::shared_ptr<BSTNode> node, const Book& book)
{
    if (!node) {
        return std::make_shared<BSTNode>(book);
    }
    
    // Compare by title (case-insensitive)
    QString currentTitle = node->book.getJudul().toLower();
    QString newTitle = book.getJudul().toLower();
    
    if (newTitle < currentTitle) {
        node->left = insertBST(node->left, book);
    } else if (newTitle > currentTitle) {
        node->right = insertBST(node->right, book);
    }
    // If equal, don't insert duplicate
    
    return node;
}

Book* BookManager::searchBST(const QString& title)
{
    return searchBSTHelper(m_bstRoot, title);
}

Book* BookManager::searchBSTHelper(std::shared_ptr<BSTNode> node, const QString& title)
{
    if (!node) {
        return nullptr;
    }
    
    QString currentTitle = node->book.getJudul().toLower();
    QString searchTitle = title.toLower();
    
    if (searchTitle == currentTitle) {
        return &(node->book);
    } else if (searchTitle < currentTitle) {
        return searchBSTHelper(node->left, title);
    } else {
        return searchBSTHelper(node->right, title);
    }
}

std::vector<Book> BookManager::searchBSTPartial(const QString& partialTitle)
{
    std::vector<Book> results;
    
    if (!m_bstRoot) {
        qDebug() << "BST is empty, cannot perform partial search";
        return results;
    }
    
    // Perform in-order traversal and collect matching books
    searchBSTPartialHelper(m_bstRoot, partialTitle.toLower(), results);
    
    qDebug() << "BST Partial Search found" << results.size() << "books matching:" << partialTitle;
    return results;
}

void BookManager::searchBSTPartialHelper(std::shared_ptr<BSTNode> node, const QString& partialTitle, std::vector<Book>& results)
{
    if (!node) {
        return;
    }
    
    // In-order traversal: left -> current -> right
    searchBSTPartialHelper(node->left, partialTitle, results);
    
    // Check if current node's title contains the partial title (case-insensitive)
    QString currentTitle = node->book.getJudul().toLower();
    if (currentTitle.contains(partialTitle)) {
        results.push_back(node->book);
    }
    
    searchBSTPartialHelper(node->right, partialTitle, results);
}

std::vector<Book> BookManager::getBSTInOrder()
{
    std::vector<Book> result;
    inOrderTraversal(m_bstRoot, result);
    return result;
}

void BookManager::inOrderTraversal(std::shared_ptr<BSTNode> node, std::vector<Book>& result)
{
    if (!node) {
        return;
    }
    
    inOrderTraversal(node->left, result);
    result.push_back(node->book);
    inOrderTraversal(node->right, result);
}

// ============================================================================
// GRAPH - Book Recommendation System Implementation
// ============================================================================

void BookManager::buildGraph()
{
    // Build graph from current books collection
    // Graph automatically creates edges based on shared genres
    m_graph.buildGraph(m_books);
    
    qDebug() << "Built graph with" << m_books.size() << "books";
}

std::vector<Book> BookManager::getRecommendations(const QString& genre, int maxRecommendations)
{
    if (m_books.empty()) {
        qDebug() << "Cannot get recommendations: Book collection is empty";
        return std::vector<Book>();
    }
    
    // Ensure graph is built
    if (!hasGraph()) {
        buildGraph();
    }
    
    // Use Graph's BFS-based recommendation system
    std::vector<Book> recommendations = m_graph.getRecommendation(genre, maxRecommendations);
    
    qDebug() << "Found" << recommendations.size() << "recommendations for genre:" << genre;
    return recommendations;
}
